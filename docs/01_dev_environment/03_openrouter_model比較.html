<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>開発用AIモデル選定の軌跡</title>
    <style>
        body {
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            color: #333;
        }
        #slide-container {
            width: 90%;
            max-width: 960px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            display: block;
        }
        #navigation {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            padding: 10px 25px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div id="slide-container">
        <canvas id="slideCanvas" width="1280" height="720"></canvas>
    </div>

    <div id="navigation">
        <button id="prevBtn">前へ</button>
        <button id="nextBtn">次へ</button>
    </div>

    <script>
        const canvas = document.getElementById('slideCanvas');
        const ctx = canvas.getContext('2d');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        let currentSlide = 0;
        const totalSlides = 8;

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split('');
            let line = '';
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n];
                let metrics = context.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    context.fillText(line, x, y);
                    line = words[n];
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            context.fillText(line, x, y);
        }

        const slides = [
            // Slide 1: Title
            () => {
                ctx.fillStyle = '#1a237e';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = 'bold 72px sans-serif';
                ctx.fillText('開発用AIモデル選定の軌跡', 1280 / 2, 300);
                ctx.font = '36px sans-serif';
                ctx.fillText('OpenRouter APIのコストパフォーマンス検討', 1280 / 2, 420);
                 ctx.font = '24px sans-serif';
                ctx.fillText('2025/08/17', 1280 / 2, 650);
            },
            // Slide 2: The Goal
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('1. 最初の課題：コスパの良いAIモデルはどれ？', 60, 120);
                ctx.fillStyle = '#333';
                ctx.font = '36px sans-serif';
                wrapText(ctx, 'OpenRouterのLeaderboardを参考に、多数のモデルの中から開発に最適な選択肢を探すことから検討を開始した。', 80, 220, 1100, 60);
                
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 2;
                ctx.strokeRect(140, 350, 1000, 300);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(141, 351, 998, 298);
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';
                ctx.font = '32px sans-serif';
                ctx.fillText('[きっかけとなったLeaderboard画像]', 1280/2, 510);
            },
            // Slide 3: Analysis
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('2. 分析と発見：ランキングの本当の意味', 60, 120);

                ctx.fillStyle = '#333';
                ctx.font = '36px sans-serif';
                ctx.fillText('・当初の推測：ランキングはモデルの「性能順」。', 80, 220);
                
                ctx.fillStyle = '#D32F2F';
                ctx.font = 'bold 38px sans-serif';
                ctx.fillText('↓', 580, 290);
                
                ctx.fillStyle = '#00796B';
                ctx.font = 'bold 36px sans-serif';
                ctx.fillText('・重要な発見：', 80, 350);
                ctx.fillStyle = '#333';
                ctx.font = '36px sans-serif';
                wrapText(ctx, 'これは「当日のトークン使用量（=人気度）」のランキングであり、「性能」そのものではないことが判明。', 290, 350, 850, 60);
                
                ctx.fillStyle = '#E8F5E9';
                ctx.fillRect(80, 480, 1120, 150);
                ctx.fillStyle = '#1B5E20';
                ctx.textAlign = 'center';
                ctx.font = 'bold 38px sans-serif';
                wrapText(ctx, '新たな視点：「市場の人気 ≒ 多くの開発者が認めるコストパフォーマンスの良さ」の指標であると理解。', 1280/2, 550, 1000, 70);
            },
            // Slide 4: Candidate 1 (DeepSeek)
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('3. 候補①：無料モデル DeepSeek の検討', 60, 120);

                ctx.fillStyle = '#333';
                ctx.font = 'bold 36px sans-serif';
                ctx.fillText('✅ 長所 (Pros)', 100, 220);
                ctx.font = '32px sans-serif';
                wrapText(ctx, '・コストがゼロ。\n・使用量ランキング5位と、無料ながら実用性が市場に証明済み。', 120, 280, 1000, 50);

                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#c62828';
                ctx.fillText('❌ 短所 (Cons) - Roo Codeでの利用時', 100, 420);
                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#333';
                wrapText(ctx, '・致命的な制限：`Does not support computer use`\n  → ファイル操作やコマンド実行が不可能。\n・画像認識、キャッシュ機能も非対応。', 120, 480, 1000, 50);
                
                ctx.font = 'bold 34px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#546E7A';
                ctx.fillText('結論：「優秀な相談役」だが「実務アシスタント」にはなれない。', 1280/2, 650);
            },
            // Slide 5: The "Computer Use" Barrier
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('4. 壁となった「PC連携機能」の仕組み', 60, 120);

                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText('なぜPCを操作できないのか？', 100, 220);
                
                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#D84315';
                ctx.fillText('理由1：セキュリティ', 120, 290);
                ctx.fillStyle = '#333';
                wrapText(ctx, 'ユーザーのPCを破壊や情報漏洩から守るため、AIは意図的に隔離された環境で動作している。', 140, 340, 1000, 50);

                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#00695C';
                ctx.fillText('理由2：技術的な仕組み', 120, 460);
                ctx.fillStyle = '#333';
                wrapText(ctx, 'AIはリモートサーバー上の「頭脳」。PCを操作するには、Roo Codeのようなローカルで動く「身体」との特別な連携（=対応モデル）が必要。', 140, 510, 1000, 50);
            },
            // Slide 6: Candidate 2 (Paid Models)
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('5. 候補②：有料モデルの比較検討', 60, 120);

                ctx.font = 'bold 34px sans-serif';
                ctx.fillStyle = '#333';
                wrapText(ctx, 'Roo Codeの「PC連携機能」はClaudeシリーズを前提としていることが判明。Claudeファミリー内でのコスパ比較へ。', 100, 200, 1100, 50);

                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#F57F17';
                ctx.fillText('Claude 3 Haiku (最安価)', 120, 320);
                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText('→ 軽量なタスクに最適。まず試すならコレ。', 140, 370);
                
                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#5E35B1';
                ctx.fillText('Claude 3.5 Sonnet (バランス型)', 120, 470);
                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText('→ Roo Code推奨。性能とコストのバランスが良い本命。', 140, 520);
                
                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#AD1457';
                ctx.fillText('Claude 3 Opus (最高性能)', 120, 620);
                ctx.font = '32px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText('→ 最終手段。コストは高いが性能は最強。', 140, 670);
            },
            // Slide 7: The Final Choice (Sonnet 4)
            () => {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = '#1a237e';
                ctx.textAlign = 'left';
                ctx.font = 'bold 52px sans-serif';
                ctx.fillText('6. 最終候補：Claude Sonnet 4', 60, 120);
                
                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#333';
                ctx.fillText('DeepSeekが持っていなかった全ての機能をサポート', 100, 220);

                ctx.font = '36px sans-serif';
                ctx.fillStyle = '#2E7D32';
                ctx.fillText('✅ Supports computer use', 120, 300);
                ctx.fillText('✅ Supports images', 120, 360);
                ctx.fillText('✅ Supports prompt caching', 120, 420);

                ctx.fillStyle = '#E8F5E9';
                ctx.fillRect(80, 500, 1120, 150);
                ctx.fillStyle = '#1B5E20';
                ctx.textAlign = 'center';
                ctx.font = 'bold 38px sans-serif';
                ctx.fillText('結論：Roo Codeのポテンシャルを100%引き出すための「フルスペックモデル」', 1280/2, 590);
            },
            // Slide 8: Final Strategy
             () => {
                ctx.fillStyle = '#1a237e';
                ctx.fillRect(0, 0, 1280, 720);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = 'bold 64px sans-serif';
                ctx.fillText('最終結論と今後の戦略', 1280 / 2, 120);
                
                ctx.textAlign = 'left';
                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = '#FFF';
                ctx.fillText('最終決定：', 120, 220);
                ctx.font = '32px sans-serif';
                wrapText(ctx, 'コストはかかるが、Roo Codeの全機能を活用するため、まずはClaude Sonnetを試用する。', 140, 270, 1000, 50);

                ctx.font = 'bold 36px sans-serif';
                ctx.fillText('今後の戦略プラン：', 120, 390);
                ctx.font = '30px sans-serif';
                ctx.fillText('1. まずは Sonnet を使い、Roo Codeの全機能を体験し、開発効率を評価する。', 140, 450);
                ctx.fillText('2. 軽量なタスクでは、コスト節約のために安価な Haiku への切り替えも検討する。', 140, 510);
                ctx.fillText('3. PC連携が不要な相談には、無料の DeepSeek を併用し、コストを最適化する。', 140, 570);
            },
        ];

        function drawSlide(slideIndex) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            slides[slideIndex]();
            updateButtons();
        }

        function updateButtons() {
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === totalSlides - 1;
        }

        prevBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                drawSlide(currentSlide);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                drawSlide(currentSlide);
            }
        });

        drawSlide(currentSlide);
    </script>

</body>
</html>